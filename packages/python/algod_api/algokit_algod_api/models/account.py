# coding: utf-8

"""
    Algod REST API.

    API endpoint for algod operations.

    The version of the OpenAPI document: 0.0.1
    Contact: contact@algorand.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from algokit_algod_api.models.account_participation import AccountParticipation
from algokit_algod_api.models.application import Application
from algokit_algod_api.models.application_local_state import ApplicationLocalState
from algokit_algod_api.models.application_state_schema import ApplicationStateSchema
from algokit_algod_api.models.asset import Asset
from algokit_algod_api.models.asset_holding import AssetHolding
from typing import Optional, Set
from typing_extensions import Self

class Account(BaseModel):
    """
    Account information at a given round.  Definition: data/basics/userBalance.go : AccountData 
    """ # noqa: E501
    address: StrictStr = Field(description="the account public key")
    amount: StrictInt = Field(description="\\[algo\\] total number of MicroAlgos in the account")
    min_balance: StrictInt = Field(description="MicroAlgo balance required by the account.  The requirement grows based on asset and application usage.", alias="min-balance")
    amount_without_pending_rewards: StrictInt = Field(description="specifies the amount of MicroAlgos in the account, without the pending rewards.", alias="amount-without-pending-rewards")
    apps_local_state: Optional[List[ApplicationLocalState]] = Field(default=None, description="\\[appl\\] applications local data stored in this account.  Note the raw object uses `map[int] -> AppLocalState` for this type.", alias="apps-local-state")
    total_apps_opted_in: StrictInt = Field(description="The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.", alias="total-apps-opted-in")
    apps_total_schema: Optional[ApplicationStateSchema] = Field(default=None, alias="apps-total-schema")
    apps_total_extra_pages: Optional[StrictInt] = Field(default=None, description="\\[teap\\] the sum of all extra application program pages for this account.", alias="apps-total-extra-pages")
    assets: Optional[List[AssetHolding]] = Field(default=None, description="\\[asset\\] assets held by this account.  Note the raw object uses `map[int] -> AssetHolding` for this type.")
    total_assets_opted_in: StrictInt = Field(description="The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.", alias="total-assets-opted-in")
    created_apps: Optional[List[Application]] = Field(default=None, description="\\[appp\\] parameters of applications created by this account including app global data.  Note: the raw account uses `map[int] -> AppParams` for this type.", alias="created-apps")
    total_created_apps: StrictInt = Field(description="The count of all apps (AppParams objects) created by this account.", alias="total-created-apps")
    created_assets: Optional[List[Asset]] = Field(default=None, description="\\[apar\\] parameters of assets created by this account.  Note: the raw account uses `map[int] -> Asset` for this type.", alias="created-assets")
    total_created_assets: StrictInt = Field(description="The count of all assets (AssetParams objects) created by this account.", alias="total-created-assets")
    total_boxes: Optional[StrictInt] = Field(default=None, description="\\[tbx\\] The number of existing boxes created by this account's app.", alias="total-boxes")
    total_box_bytes: Optional[StrictInt] = Field(default=None, description="\\[tbxb\\] The total number of bytes used by this account's app's box keys and values.", alias="total-box-bytes")
    participation: Optional[AccountParticipation] = None
    incentive_eligible: Optional[StrictBool] = Field(default=None, description="Whether or not the account can receive block incentives if its balance is in range at proposal time.", alias="incentive-eligible")
    pending_rewards: StrictInt = Field(description="amount of MicroAlgos of pending rewards in this account.", alias="pending-rewards")
    reward_base: Optional[StrictInt] = Field(default=None, description="\\[ebase\\] used as part of the rewards computation. Only applicable to accounts which are participating.", alias="reward-base")
    rewards: StrictInt = Field(description="\\[ern\\] total rewards of MicroAlgos the account has received, including pending rewards.")
    round: StrictInt = Field(description="The round for which this information is relevant.")
    status: StrictStr = Field(description="\\[onl\\] delegation status of the account's MicroAlgos * Offline - indicates that the associated account is delegated. *  Online  - indicates that the associated account used as part of the delegation pool. *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.")
    sig_type: Optional[StrictStr] = Field(default=None, description="Indicates what type of signature is used by this account, must be one of: * sig * msig * lsig", alias="sig-type")
    auth_addr: Optional[StrictStr] = Field(default=None, description="\\[spend\\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.", alias="auth-addr")
    last_proposed: Optional[StrictInt] = Field(default=None, description="The round in which this account last proposed the block.", alias="last-proposed")
    last_heartbeat: Optional[StrictInt] = Field(default=None, description="The round in which this account last went online, or explicitly renewed their online status.", alias="last-heartbeat")
    __properties: ClassVar[List[str]] = ["address", "amount", "min-balance", "amount-without-pending-rewards", "apps-local-state", "total-apps-opted-in", "apps-total-schema", "apps-total-extra-pages", "assets", "total-assets-opted-in", "created-apps", "total-created-apps", "created-assets", "total-created-assets", "total-boxes", "total-box-bytes", "participation", "incentive-eligible", "pending-rewards", "reward-base", "rewards", "round", "status", "sig-type", "auth-addr", "last-proposed", "last-heartbeat"]

    @field_validator('sig_type')
    def sig_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['sig', 'msig', 'lsig']):
            raise ValueError("must be one of enum values ('sig', 'msig', 'lsig')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Account from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in apps_local_state (list)
        _items = []
        if self.apps_local_state:
            for _item_apps_local_state in self.apps_local_state:
                if _item_apps_local_state:
                    _items.append(_item_apps_local_state.to_dict())
            _dict['apps-local-state'] = _items
        # override the default output from pydantic by calling `to_dict()` of apps_total_schema
        if self.apps_total_schema:
            _dict['apps-total-schema'] = self.apps_total_schema.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in assets (list)
        _items = []
        if self.assets:
            for _item_assets in self.assets:
                if _item_assets:
                    _items.append(_item_assets.to_dict())
            _dict['assets'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in created_apps (list)
        _items = []
        if self.created_apps:
            for _item_created_apps in self.created_apps:
                if _item_created_apps:
                    _items.append(_item_created_apps.to_dict())
            _dict['created-apps'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in created_assets (list)
        _items = []
        if self.created_assets:
            for _item_created_assets in self.created_assets:
                if _item_created_assets:
                    _items.append(_item_created_assets.to_dict())
            _dict['created-assets'] = _items
        # override the default output from pydantic by calling `to_dict()` of participation
        if self.participation:
            _dict['participation'] = self.participation.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Account from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "address": obj.get("address"),
            "amount": obj.get("amount"),
            "min-balance": obj.get("min-balance"),
            "amount-without-pending-rewards": obj.get("amount-without-pending-rewards"),
            "apps-local-state": [ApplicationLocalState.from_dict(_item) for _item in obj["apps-local-state"]] if obj.get("apps-local-state") is not None else None,
            "total-apps-opted-in": obj.get("total-apps-opted-in"),
            "apps-total-schema": ApplicationStateSchema.from_dict(obj["apps-total-schema"]) if obj.get("apps-total-schema") is not None else None,
            "apps-total-extra-pages": obj.get("apps-total-extra-pages"),
            "assets": [AssetHolding.from_dict(_item) for _item in obj["assets"]] if obj.get("assets") is not None else None,
            "total-assets-opted-in": obj.get("total-assets-opted-in"),
            "created-apps": [Application.from_dict(_item) for _item in obj["created-apps"]] if obj.get("created-apps") is not None else None,
            "total-created-apps": obj.get("total-created-apps"),
            "created-assets": [Asset.from_dict(_item) for _item in obj["created-assets"]] if obj.get("created-assets") is not None else None,
            "total-created-assets": obj.get("total-created-assets"),
            "total-boxes": obj.get("total-boxes"),
            "total-box-bytes": obj.get("total-box-bytes"),
            "participation": AccountParticipation.from_dict(obj["participation"]) if obj.get("participation") is not None else None,
            "incentive-eligible": obj.get("incentive-eligible"),
            "pending-rewards": obj.get("pending-rewards"),
            "reward-base": obj.get("reward-base"),
            "rewards": obj.get("rewards"),
            "round": obj.get("round"),
            "status": obj.get("status"),
            "sig-type": obj.get("sig-type"),
            "auth-addr": obj.get("auth-addr"),
            "last-proposed": obj.get("last-proposed"),
            "last-heartbeat": obj.get("last-heartbeat")
        })
        return _obj


